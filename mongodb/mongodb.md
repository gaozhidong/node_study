 // tremendous   巨大的


 // deepin       深化版的
 # MongoDB

```
一个mongoDB实例可以承载多个数据库，每个数据库拥有0个或者多个集合
每个数据库有独立的权限，即便是在磁盘上，不同的数据库也放置在不同的文件中。
数据库通过名称来标识。 不能是空字符串  简单起见，数据库名应全部小写。

一些数据库名是保留的，可以直接访问有特殊语义的数据库。
admin  从身份验证的角度来讲，这是“root”数据库。如果将一个用户添加到admin数据库，这个用户将自动获得所有数据库的权限
	一些特定的服务器端命令也只能从admin数据库运行。如列出所有数据库或关闭服务器

local 这个数据库永远都不可以复制，切一台服务器上的所有本地集合都可以存储在这个数据库中

config MongonDB用于分片设置时，分片信息会存储在config数据库中。  
```

#### 启动MongoDB

通常MongoDB作为网络服务器来运行，客户端可连接到该服务器并执行操作。

#### 简单操作：

> cmd下在安装目录的bin目录下运行mongod.exe 。新开一个cmd 运行mongo 进入shell

```
mongod --prot 27018 --depath mongo_demo 

--prot 指定了端口

--depath 指定了数据存放的目录

```

#### shell的基本操作：增删改查

```
//列出所有的数据库  
库操作 
		查看当前链接在哪个数据库下  db

		切换数据库 use `数据库名称`

　　新建数据库：第一步：use 新建数据库名；第二步：进行此库相关的操作；如果不进行第二步，该数据库不会被创建

　　查看数据库：show dbs; 或者  show databases; 

　　新建表：db.createCollection('要新建的表名');

　　查看当前数据库下表： show collections;

　　删除当前数据库指定表：db.表名.drop();

　　删除当前数据库：db.dropDatabase();

 
```

1. 创建
```
 insert函数可将一个文档添加到集合中。

 首先，创建一个名为post的局部变量，这是一个JavaScript对象，用于表示文档。有几个键："title","content","date"

post = {
	"title":"my Blog post",
	"content":"Here's my blog post.",
	"date":new Date()
	}
	
	用insert方法将其保存到blog集合中：
	db.blog.insert(post)

	用find方法调用集合
	db.blog.find()

 ```

 2. 读取

 ```
	find和findOne方法可以用于查询集合里的文档。若只想查看一个文档，可用findOne  ** db.blog.findOne() **

	find和findOne可以接受一个查询文档作为限定条件。这样就可以查询符合一定条件的文档。

```

3. 更新

```
使用update。update接受(至少)两个参数：第一个是限定条件(用于匹配更新的文档)，第二个是新的文档。
```

4. 删除

```
使用remove方法可将文档从数据库中永久删除。如果没有使用任何参数，它会将集合内的所有文档全部删除。它可以接受一个作为限定条件的文档作为参数。
如：db.blog.remove({title:"my Blog Post"})
```

### 数据类型

#### 基本数据类型
1. null  null用于表示空值或者不存在的字段
```
{"x":null}
```
2. 布尔型

> 布尔类型有两个值true和false

3. 数值
```
shell 默认使用64位浮点型数值。
{"x":3.14} 或者 {"x":3} 

对于整数型，可使用NumberInt类(表示4字节带符号整数)或NumberLong类(表示8字符带符号整数)
{"x":NumberInt("3")}
{"x":NumberLong("3")}

```

4. 字符串

> {"x":"foobar"}

5. 日期

> 日期被存储为自新纪元以来经过的毫秒数，不储存时区：
```
{"x":new Date()}
```

6. 正则表达式
> 查询时，使用正则表达式作为限定条件，语法也与JavaScript的正则表达式语法相同：

```
{"x":/foobar/i}
```

7. 数组
> 数据列表或数据集可以表示为数组：

```
{"x":["a","b","c"]}
```

8. 内嵌文档
> 文档可以嵌套其他文档，被嵌套的文档作为父文档的值：
```
{"x":{"foo":"bar"}}
```

9. 对象id
> 对象id是一个12字节的ID，是文档的唯一标识。
```
{"x":ObjectID()}
```

10. 其他

> 二进制数据 (二进制数据是一个任意字节的字符串。他不能直接在shell中使用。如果要将非 UTF-8 字符保存到数据库中，二进制数据是唯一的方式)
> 代码 (查询和文档中可以包括任意JavaScript代码：)
```
{"X":function(){/**/}}
```

### 创建、更新和删除文档

#### 插入并保存文档
> 插入是像MongoDB中添加数据的基本方法。可以使用insert方法向目标集合插入一个文档：
```
db.foo.insert({"bar":"baz"})

这个操作会给文档自动增加一个"_id"键(要是原来没有的话)，然后将其保存到MongoDB中。
```

1. 批量插入
> 如果要向集合中插入多个文档，使用批量插入会快一些。使用批量插入，可以将一组文档传递给数据库。在shell中，可以使用batchInsert函数实现批量插入，它与insert函数非常像，只是它接受的是一个文档数组作为参数：
```
db.foo.batchInsert([{"_id":0},{"_id":1},{"_id":2}])

db.foo.find()
```

#### 删除文档
1. 删除数据 
> db.foo.remove() //会删除foo集合中的所有文档。但是不会删除集合本身，也不会删除集合的元信息。
> remove函数可以接受一个查询文档作为可选参数。给定这个参数以后，只有符合条件的文档才被删除。
> 删除数据是永久性的，不能撤销，也不能恢复。

2. 删除速度
> 删除文档通常很快，但是如果要清空整个集合，那么使用drop直接删除集合会更快(然后在这个空集合上重建各项索引)。

#### 更新文档
> 文档存入数据库以后，就可以使用updage方法来更新它。update有两个参数，一个是查询文档，用于定位需要更新的目标文档；另一个是修改器(modifier)文档，用于说明要对找到的文档进行哪些修改。

> 更新操作是不可分割的：若是两个更新同时发生，先到达服务器的先执行，接着执行另外一个。所以，两个需要同时进行的更新会迅速接连完成，此过程不会破坏文档：最新的更新会取得"胜利".

1. 文档替换
最简单的更新就是用一个新文档完全替换匹配的文档。这适用于大规模模式迁移的情况。