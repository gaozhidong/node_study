# 图解HTTP笔记

## 使用HTTp协议访问Web
> 当在浏览器的地址栏内输入URL时，可以看到Web页面

1. 在浏览器地址栏输入URL后，信息会被送往某处 => 根据指定的URL，web浏览器从Web服务器端获取文件资源等信息

2. 然后从某处获得的回复，内容就会显示在Web页面上

## http的诞生
#### HTTP/0.9


HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。
最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。

> GET /index.html


上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。
协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。
```
<html>
  <body>Hello World</body>
</html>
```

服务器发送完毕，就关闭TCP连接。

#### HTTP/1.0
1. 简介
>1996年5月，HTTP/1.0 版本发布，内容大大增加。
首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。
其次，除了GET命令，还引入了**POST**命令和**HEAD**命令，丰富了浏览器与服务器的互动手段。
再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括**头信息**（HTTP header），用来描述一些元数据。
其他的新增功能还包括**状态码**（status code）、**多字符集支持**、**多部分发送**（multi-part type）、**权限**（authorization）、**缓存**（cache）、**内容编码**（content encoding）等。

2. 缺点
> HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

> TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。

> 为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。
```
Connection: keep-alive
```
这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。
```
Connection: keep-alive
```
一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。

#### HTTP/1.1
>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。


1. 持久连接

1.1版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。
```
Connection: close
```
目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。

2. 缺点

虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。

#### SPDY 协议
2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。
这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。
#### HTTP/2
2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。

### 网络基础 TCP/IP

通常使用的网络是在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。

计算机与网络设备要相互通信，双方就必须基于相同的方法

TCP/IP 协议族里重要的一点就是分成。TCP/IP 协议族按层次分别分为4层：应用层、传输层、网络层和数据链路层。

**应用层**
> 应用层决定向用户提供应用服务时通信的活动。

>TCP/IP协议族内预存了各类通用的应用服务。FTP和DNS 

> HTTP 协议也处于该层

**传输层**

> 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输

> 在传输层有两个性质不同的协议：TCP(Transmissinon Control Protocol,传输控制协议)和UDP(Usre Data Protocol,用户数据报协议)。

**网络层**

> 网络层用来处理在网络上流动的数据报。数据包是网络传输的最小数据单位。改层规定了通过怎样的路径到达对方的计算机，并把数据包传送给对方。

> 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线


**数据链路层**

> 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC(Network Interface Card,网络适配器，即网卡)，及光纤等物理可见部分。



#### URL 格式

常见的URL主要由三部分组成


1. 方案(协议)
2. 服务器位置
3. 资源路径

```
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<hash>
```
* 对于web页面来说最常用的协议就是http和https

* user和password现在不常见了，不会在URL明文书写用户名和密码了，都是通过登录的方式

* 主机可以是IPO地址过着域名

* 端口号用来区分主机上的进程，方便找到web服务器，http默认是80

* path是资源的路径，也就是存放位置，不一定和物理路径完全对应，符合web服务器路由约定即可

* params，在一些协议中需要参数来访问资源，例如ftp是二进制还是文本传输，参数是名值对，用;隔开

* query：这个是get请求最常用的传递参数方式了 ?a=1&b=2&=3

* hash也成为片段，设计为标识文档的一部分，很多MVVM框架用作了路由功能


#### 报文

HTTP报文是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，描述报文的内容及含义，后面跟着可选的数据部分

##### 组成

HTTP报文是简单的格式化数据块，每个报文都包含一条来自客户端的请求或者一条来自服务器的响应，有3个部分组成

1. 对报文进行描述的起始行 -- start line
2. 包含属性的首部块  -- header
3. 可选的包含数据的主题部分 -- body

```
HTTP/1.0 200 OK
content-type: text/plain
content-length: 19

Hi, I'm a message
```
起始行和首部就是由行分隔的ASCII文本，主题是一个可选的数据块，可能是文本、二进制或者空

##### 语法

HTTP报文分为两类

###### 请求报文
向web服务器请求一个动作

```
<method><request-URL><version>
<headers>

<entity-body>
```

###### 相应报文

将请求结果返回给客户端
```
<version><status><reason-phrase>
<headers>

<entity-body>
```
首部和方法配合，共同决定了服务器和客户端能做什么


##### 通用首部

客户端和服务器都可以实用的就是通用首部

首部              | 描述
--------------    | ----------------------------------------
Connection        | 客户端和服务器是否保持连接
Date              | 日期，报文创建时间
Update            | 给出了发送端可能想要升级使用新版本或协议
Via               | 显示了报文经过的中间节点（代理、网关）
Trailer           | 如果报文采用分块传输编码方式，可以利用这个首部列出位于报文trailer部分的首部集合
Trailer-Encoding  | 告诉接收端对报文采用什么编码格式
Cache-Control     |	随报文传送缓存指示
Pragma            | 早期的随报文传送指示方式


##### 请求头部

首部                | 描述
--------------      | ----------------------------------------
Client-IP           | 客户端IP
From                | 客户端邮件地址
Host                | 接收请求的服务器的主机名和端口号
Referer             | 提供了包含当前请求URI的文档的URL，告诉服务器自己来源
User--Agent         | 发起请求的客户端应用程序
Accept              | 告诉服务器能够发送那些媒体类型
Accept-Charset      |	告诉服务器能够发送那些字符集
Accept-Encoding     | 告诉服务器能够发送那些编码
Accept-Language     | 告诉服务器能够发送那些语言
Expect              | 允许客户端列出请求所要求的服务器行为
If-Match            | 如果ETag和文档当前ETag匹配，就获取文档
If-Modified-Since   | 除非在某个指定日期之后修改过，否则限制这个请求
If-None-Match       | 如果ETag和当前文档ETag不符合，获取资源
If-Range            | 允许对文档否个范围内的条件请求
If-Unmodified-Since | 在某个指定日期之后没有修改过，否则现在请求
Cookie              | 客户端字符串


##### 响应头部

首部                | 描述
--------------      | ----------------------------------------
Age                 | 响应持续时间
Server              | 	服务器应用软件名称和版本
Allow               | 列出了可用的请求方法
Location            | 告诉客户端实在在哪里，用于定向
Content-Base        | 解析主体中相对URL的基础URL
Content-Encoding    | 主体编码格式
Content-Language    |	解析主体时适用的语言
Content-Length      | 主体的长度或尺寸
Content-Location    | 资源实际位置
Content-MD5         | 主体的MD5校验和
Content-Range       | 	在整个资源中此实体部分的字节范围
Content-Type        | 主体的MIME
ETag                | 主体的实体标记
Expires             | 过期时间
Last-Modified       | 实体最后一次修改时间



















## 参考链接

[HTTP协议入门](http://www.ruanyifeng.com/blog/2016/08/http.html) 阮一峰
